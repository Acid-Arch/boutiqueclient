import { SvelteKitAuth } from '@auth/sveltekit';
import Google from '@auth/core/providers/google';
import type { Provider } from '@auth/core/providers';
import { dev } from '$app/environment';
import { GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET } from '$env/static/private';
import { OAuthService, type GoogleProfile } from '$lib/server/oauth-service.js';

// Auth.js configuration
export const { handle: authHandle, signIn, signOut } = SvelteKitAuth({
  providers: [
    Google({
      clientId: GOOGLE_CLIENT_ID,
      clientSecret: GOOGLE_CLIENT_SECRET,
      authorization: {
        params: {
          scope: 'openid email profile',
          access_type: 'offline',
          prompt: 'select_account',
          redirect_uri: process.env.GOOGLE_OAUTH_REDIRECT_URI || 'http://localhost:5173/auth/callback/google'
        }
      }
    })
  ] as Provider[],
  
  // Session configuration
  session: {
    strategy: 'jwt',
    maxAge: 7 * 24 * 60 * 60, // 7 days in seconds
    updateAge: 24 * 60 * 60, // Update session every 24 hours
  },
  
  // Cookies configuration for security
  cookies: {
    sessionToken: {
      name: 'next-auth.session-token',
      options: {
        httpOnly: true,
        sameSite: 'lax',
        path: '/',
        secure: !dev, // Use secure cookies in production
        domain: dev ? 'localhost' : undefined // Set domain for production
      }
    },
    callbackUrl: {
      name: 'next-auth.callback-url',
      options: {
        httpOnly: true,
        sameSite: 'lax',
        path: '/',
        secure: !dev
      }
    },
    csrfToken: {
      name: 'next-auth.csrf-token',
      options: {
        httpOnly: true,
        sameSite: 'lax',
        path: '/',
        secure: !dev
      }
    }
  },
  
  // CSRF protection
  useSecureCookies: !dev,
  
  // JWT configuration (for database session tokens)
  jwt: {
    maxAge: 7 * 24 * 60 * 60, // 7 days in seconds
  },
  
  // Page configuration
  pages: {
    signIn: '/login',
    error: '/login',
    signOut: '/login'
  },
  
  // Callback configuration  
  callbacks: {
    async signIn({ user, account, profile }) {
      try {
        // Validate Google profile data
        if (account?.provider !== 'google' || !profile) {
          console.error('Invalid OAuth provider or missing profile');
          return false;
        }
        
        // Cast profile to GoogleProfile for type safety
        const googleProfile = profile as GoogleProfile;
        
        // Validate profile structure
        if (!OAuthService.validateGoogleProfile(googleProfile)) {
          console.error('Invalid Google profile structure:', googleProfile);
          return false;
        }
        
        // Check if user can link OAuth account
        const linkCheck = await OAuthService.canLinkOAuthAccount(googleProfile.email, 'google');
        if (!linkCheck.canLink) {
          console.error('Cannot link OAuth account:', linkCheck.reason);
          // Store error for display on login page
          return `/login?error=oauth_link_failed&reason=${encodeURIComponent(linkCheck.reason || 'Unknown error')}`;
        }
        
        return true;
        
      } catch (error) {
        console.error('SignIn callback error:', error);
        return false;
      }
    },
    
    async jwt({ token, user, account, profile }) {
      // Handle initial sign in
      if (account && profile && user) {
        try {
          const googleProfile = profile as GoogleProfile;
          
          // Use OAuthService to handle user creation/linking
          const oauthResult = await OAuthService.handleGoogleCallback(googleProfile);
          
          if (!oauthResult.success) {
            console.error('OAuth callback failed:', oauthResult.error);
            throw new Error(oauthResult.error || 'OAuth authentication failed');
          }
          
          // Store user data in JWT token for session
          token.userId = oauthResult.user?.id;
          token.email = oauthResult.user?.email;
          token.name = oauthResult.user?.name;
          token.role = oauthResult.user?.role;
          token.isNewUser = oauthResult.isNewUser;
          token.accountLinked = oauthResult.accountLinked;
          
        } catch (error) {
          console.error('JWT callback error:', error);
          throw error;
        }
      }
      
      return token;
    },
    
    async session({ session, token }) {
      // Add custom user data to session
      if (token.userId) {
        session.user.id = token.userId as string;
        session.user.role = token.role as string;
        session.user.isNewUser = token.isNewUser as boolean;
        session.user.accountLinked = token.accountLinked as boolean;
      }
      
      return session;
    },
    
    async redirect({ url, baseUrl }) {
      // Handle redirects after authentication
      if (url.startsWith('/')) {
        return `${baseUrl}${url}`;
      }
      
      // Check for return URL parameter
      const returnUrl = new URL(url).searchParams.get('redirectTo') || 
                       new URL(url).searchParams.get('callbackUrl');
      
      if (returnUrl && returnUrl.startsWith('/')) {
        return `${baseUrl}${returnUrl}`;
      }
      
      // Default redirect to client portal
      return `${baseUrl}/client-portal`;
    }
  },
  
  // Events for logging and analytics
  events: {
    async signIn({ user, account, profile, isNewUser }) {
      console.log(`User signed in: ${user.email} (new: ${isNewUser}, provider: ${account?.provider})`);
    }
    // signOut callback removed due to Auth.js v5 parameter type changes
  },
  
  // Debug logging in development
  debug: dev,
  
  // Trust host configuration
  trustHost: true,
  
  // Secret for signing JWTs and encrypting sessions - REQUIRED
  secret: (() => {
    const secret = process.env.AUTH_SECRET || process.env.NEXTAUTH_SECRET;
    
    if (!secret) {
      if (dev) {
        console.warn('‚ö†Ô∏è  WARNING: No AUTH_SECRET found. Using development-only secret. Generate a secure secret for production!');
        console.warn('   Run: npm run generate:secrets');
        return 'development-only-secret-not-for-production-use-generate-secure-secret-with-npm-run-generate-secrets';
      }
      throw new Error('üö® CRITICAL: AUTH_SECRET environment variable is required in production. Run: npm run generate:secrets');
    }
    
    // Validate secret strength in production
    if (!dev) {
      if (secret.length < 32) {
        throw new Error('üö® SECURITY: AUTH_SECRET must be at least 32 characters in production. Run: npm run generate:secrets');
      }
      
      // Check for weak patterns
      const weakPatterns = ['development', 'test', 'secret', 'password', '12345', 'admin', 'default', 'example'];
      const lowerSecret = secret.toLowerCase();
      
      for (const pattern of weakPatterns) {
        if (lowerSecret.includes(pattern)) {
          throw new Error(`üö® SECURITY: AUTH_SECRET contains weak pattern '${pattern}'. Generate a strong secret: npm run generate:secrets`);
        }
      }
      
      console.log('‚úÖ AUTH_SECRET validation passed');
    }
    
    return secret;
  })()
});

// Export custom types for TypeScript
declare module '@auth/core/types' {
  interface Session {
    user: {
      id: string;
      email: string;
      name: string;
      image?: string;
      role: string;
      isNewUser: boolean;
      accountLinked: boolean;
    };
  }
  
  interface User {
    id: string;
    email: string;
    name: string;
    image?: string;
    role: string;
  }
  
  interface JWT {
    userId: string;
    email: string;
    name: string;
    role: string;
    isNewUser: boolean;
    accountLinked: boolean;
  }
}